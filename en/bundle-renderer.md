# Introducing Bundle Renderer

## Problems with Basic SSR

In our basic usage example, we directly required Vue and created an app instance in our Node.js server code. This is straightforward, however has quite a few issues in practice:

- Typical Vue apps are built with webpack and `vue-loader`, and many webpack-specific features such as importing files via `file-loader`, importing CSS via `css-loader` would not work directly in Node.js.

- Although the latest version of Node.js fully supports ES2015 features, we still need to transpile client-side code to cater to older browsers. This again involves a build step.

- Getting source maps to work with Node.js can be tricky.

- Directly requiring Vue app code in the server process means whenever you edit your app source code, you would have to stop and restart the server. Ideally, we want our server-rendering logic to be hot-reloadable too!

## Enter BundleRenderer

![architecture](https://cloud.githubusercontent.com/assets/499550/17607895/786a415a-5fee-11e6-9c11-45a2cfdf085c.png)

`vue-server-renderer` provides an API called `createBundleRenderer` to deal with these problems. The basic idea is that we use the same Vue app source code to generate two bundles - one for the client and one for the server. With a custom webpack plugin, the server bundle is generated as a special JSON file that can be passed to the bundle renderer. Once the bundle renderer is created, usage is the same as the normal renderer, however the bundle renderer provides the following benefits:

- Reuse the vast majority of the app source code and build configuration for both server and client

- Built-in source map support for runtime errors

- Hot-reload during development and even deployment (by simply reading the updated bundle and re-creating the renderer instance)

- Seamlessly supports webpack code-splitting (lazy loading)

- Critical CSS injection (when using `*.vue` files): automatically inlines the CSS needed by components used during the render. See the [CSS](./css.md) section for more details.

- Asset injection with [clientManifest](./client-manifest.md): automatically infers the optimal preload and prefetch directives, and the code-split chunks needed for the initial render.

---

We will discuss how to configure webpack to generate the build artifacts needed by the bundle renderer in the next section, but for now let's assume we already have what we need, and this is how to create a use a bundle renderer:

``` js
const renderer = require('vue-server-renderer').createBundleRenderer(
  bundle, // server bundle generated by the server build
  {
    template, // page template
    clientManifest // client build manifest generated by the client build
  }
)

// inside a server handler...
server.get('*', (req, res) => {
  const context = { url: req.url }
  // No need to pass an app here because it is auto-created by the
  // executing the bundle. Now our server is decoupled from our Vue app!
  renderer.renderToString(context, (err, html) => {
    // handle error...
    res.end(html)
  })
})
```
